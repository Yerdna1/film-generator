// Unified TTS API Route - Routes to appropriate provider based on user settings
// Supports: Gemini TTS, ElevenLabs, Modal (self-hosted), OpenAI TTS

import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db/prisma';
import { spendCredits, COSTS, checkBalance } from '@/lib/services/credits';
import { calculateVoiceCost } from '@/lib/services/real-costs';
import { uploadAudioToS3, isS3Configured } from '@/lib/services/s3-upload';
import { rateLimit } from '@/lib/services/rate-limit';
import type { TTSProvider } from '@/types/project';

const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta';
const ELEVENLABS_API_URL = 'https://api.elevenlabs.io/v1';
const OPENAI_API_URL = 'https://api.openai.com/v1/audio/speech';

export const maxDuration = 60;

interface TTSRequest {
  text: string;
  voiceId?: string;
  voiceName?: string;
  language?: string;
  projectId?: string;
  provider?: TTSProvider;  // Allow overriding provider from UI
  // Voice customization settings
  voiceInstructions?: string;      // OpenAI: speaking style instructions
  voiceStability?: number;         // ElevenLabs: 0-1
  voiceSimilarityBoost?: number;   // ElevenLabs: 0-1
  voiceStyle?: number;             // ElevenLabs: 0-1
}

// Add WAV headers to raw PCM audio data
function addWavHeaders(pcmData: Buffer, sampleRate: number, numChannels: number, bitsPerSample: number): Buffer {
  const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
  const blockAlign = numChannels * (bitsPerSample / 8);
  const dataSize = pcmData.length;
  const headerSize = 44;
  const fileSize = headerSize + dataSize - 8;

  const header = Buffer.alloc(headerSize);
  header.write('RIFF', 0);
  header.writeUInt32LE(fileSize, 4);
  header.write('WAVE', 8);
  header.write('fmt ', 12);
  header.writeUInt32LE(16, 16);
  header.writeUInt16LE(1, 20);
  header.writeUInt16LE(numChannels, 22);
  header.writeUInt32LE(sampleRate, 24);
  header.writeUInt32LE(byteRate, 28);
  header.writeUInt16LE(blockAlign, 32);
  header.writeUInt16LE(bitsPerSample, 34);
  header.write('data', 36);
  header.writeUInt32LE(dataSize, 40);

  return Buffer.concat([header, pcmData]);
}

// Generate audio using Gemini TTS
async function generateWithGemini(
  text: string,
  voiceName: string,
  language: string,
  projectId: string | undefined,
  apiKey: string,
  userId: string | undefined
): Promise<{ audioUrl: string; cost: number; storage: string }> {
  const formattedText = language === 'sk'
    ? `Hovor po slovensky s prirodzeným prízvukom: "${text}"`
    : text;

  const response = await fetch(
    `${GEMINI_API_URL}/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: formattedText }] }],
        generationConfig: {
          responseModalities: ['AUDIO'],
          speechConfig: {
            voiceConfig: { prebuiltVoiceConfig: { voiceName } },
          },
        },
      }),
    }
  );

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'Failed to generate speech with Gemini');
  }

  const data = await response.json();
  const audioData = data.candidates?.[0]?.content?.parts?.[0]?.inlineData;

  if (!audioData) {
    throw new Error('No audio generated by Gemini');
  }

  let base64AudioUrl: string;
  const mimeType = audioData.mimeType?.toLowerCase() || '';

  if (mimeType.includes('l16') || mimeType.includes('pcm')) {
    const rateMatch = mimeType.match(/rate=(\d+)/);
    const sampleRate = rateMatch ? parseInt(rateMatch[1]) : 24000;
    const pcmBuffer = Buffer.from(audioData.data, 'base64');
    const wavBuffer = addWavHeaders(pcmBuffer, sampleRate, 1, 16);
    base64AudioUrl = `data:audio/wav;base64,${wavBuffer.toString('base64')}`;
  } else {
    base64AudioUrl = `data:${audioData.mimeType};base64,${audioData.data}`;
  }

  const realCost = calculateVoiceCost(text.length, 'geminiTts');

  if (userId) {
    await spendCredits(userId, COSTS.VOICEOVER_LINE, 'voiceover', `Gemini TTS (${text.length} chars)`, projectId, 'gemini-tts', { characterCount: text.length }, realCost);
  }

  let audioUrl = base64AudioUrl;
  if (isS3Configured()) {
    const uploadResult = await uploadAudioToS3(base64AudioUrl, projectId);
    if (uploadResult.success && uploadResult.url) {
      audioUrl = uploadResult.url;
    }
  }

  return { audioUrl, cost: realCost, storage: isS3Configured() && !audioUrl.startsWith('data:') ? 's3' : 'base64' };
}

// Generate audio using ElevenLabs
async function generateWithElevenLabs(
  text: string,
  voiceId: string,
  projectId: string | undefined,
  apiKey: string,
  userId: string | undefined,
  stability: number,
  similarityBoost: number,
  style: number
): Promise<{ audioUrl: string; cost: number; storage: string }> {
  const response = await fetch(
    `${ELEVENLABS_API_URL}/text-to-speech/${voiceId}`,
    {
      method: 'POST',
      headers: {
        'xi-api-key': apiKey,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        text,
        model_id: 'eleven_multilingual_v2',
        voice_settings: {
          stability,
          similarity_boost: similarityBoost,
          style,
          use_speaker_boost: true,
        },
      }),
    }
  );

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail?.message || 'Failed to generate speech with ElevenLabs');
  }

  const audioBlob = await response.blob();
  const audioBuffer = await audioBlob.arrayBuffer();
  const base64 = Buffer.from(audioBuffer).toString('base64');
  const base64AudioUrl = `data:audio/mpeg;base64,${base64}`;

  const realCost = calculateVoiceCost(text.length, 'elevenlabs');

  if (userId) {
    await spendCredits(userId, COSTS.VOICEOVER_LINE, 'voiceover', `ElevenLabs TTS (${text.length} chars)`, projectId, 'elevenlabs', { characterCount: text.length }, realCost);
  }

  let audioUrl = base64AudioUrl;
  if (isS3Configured()) {
    const uploadResult = await uploadAudioToS3(base64AudioUrl, projectId);
    if (uploadResult.success && uploadResult.url) {
      audioUrl = uploadResult.url;
    }
  }

  return { audioUrl, cost: realCost, storage: isS3Configured() && !audioUrl.startsWith('data:') ? 's3' : 'base64' };
}

// Generate audio using OpenAI TTS (gpt-4o-mini-tts)
async function generateWithOpenAI(
  text: string,
  voiceId: string,
  language: string,
  projectId: string | undefined,
  apiKey: string,
  userId: string | undefined,
  voiceInstructions?: string
): Promise<{ audioUrl: string; cost: number; storage: string }> {
  console.log('[OpenAI TTS] Generating with voice:', voiceId);

  // Combine language instructions with user-provided voice instructions
  const languageInstruction = language === 'sk'
    ? 'Speak in Slovak with natural pronunciation and intonation.'
    : '';

  // Merge language and custom instructions
  const instructions = [languageInstruction, voiceInstructions].filter(Boolean).join(' ') || undefined;

  const response = await fetch(OPENAI_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini-tts',
      input: text,
      voice: voiceId,
      response_format: 'mp3',
      ...(instructions && { instructions }),
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`OpenAI TTS generation failed: ${errorText}`);
  }

  // Get audio as blob
  const audioBlob = await response.blob();
  const audioBuffer = await audioBlob.arrayBuffer();
  const base64 = Buffer.from(audioBuffer).toString('base64');
  const base64AudioUrl = `data:audio/mpeg;base64,${base64}`;

  // OpenAI TTS pricing: $15 per 1M characters = $0.015 per 1K chars
  const realCost = calculateVoiceCost(text.length, 'openaiTts');

  if (userId) {
    await spendCredits(userId, COSTS.VOICEOVER_LINE, 'voiceover', `OpenAI TTS (${text.length} chars)`, projectId, 'openai-tts', { characterCount: text.length }, realCost);
  }

  let audioUrl = base64AudioUrl;
  if (isS3Configured()) {
    const uploadResult = await uploadAudioToS3(base64AudioUrl, projectId);
    if (uploadResult.success && uploadResult.url) {
      audioUrl = uploadResult.url;
    }
  }

  return { audioUrl, cost: realCost, storage: isS3Configured() && !audioUrl.startsWith('data:') ? 's3' : 'base64' };
}

// Generate audio using Modal (self-hosted)
async function generateWithModal(
  text: string,
  voiceId: string | undefined,
  language: string,
  projectId: string | undefined,
  modalEndpoint: string,
  userId: string | undefined
): Promise<{ audioUrl: string; cost: number; storage: string }> {
  console.log('[Modal] Generating TTS with endpoint:', modalEndpoint);

  const response = await fetch(modalEndpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      text,
      voice_id: voiceId,
      language,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Modal TTS generation failed: ${errorText}`);
  }

  const data = await response.json();

  let audioUrl: string;
  if (data.audio) {
    audioUrl = data.audio.startsWith('data:') ? data.audio : `data:audio/wav;base64,${data.audio}`;
  } else if (data.audioUrl) {
    audioUrl = data.audioUrl;
  } else {
    throw new Error('Modal endpoint did not return audio');
  }

  const realCost = 0.01; // Modal GPU cost per TTS line (~$0.01)

  if (userId) {
    await spendCredits(userId, COSTS.VOICEOVER_LINE, 'voiceover', `Modal TTS (${text.length} chars)`, projectId, 'modal', { characterCount: text.length }, realCost);
  }

  if (isS3Configured() && audioUrl.startsWith('data:')) {
    const uploadResult = await uploadAudioToS3(audioUrl, projectId);
    if (uploadResult.success && uploadResult.url) {
      audioUrl = uploadResult.url;
    }
  }

  return { audioUrl, cost: realCost, storage: audioUrl.startsWith('data:') ? 'base64' : 's3' };
}

export async function POST(request: NextRequest) {
  // SECURITY: Rate limit generation to prevent abuse (20 requests/min)
  const rateLimitResult = await rateLimit(request, 'generation');
  if (rateLimitResult) return rateLimitResult;

  try {
    const {
      text,
      voiceId = 'pNInz6obpgDQGcFmaJgB',
      voiceName = 'Aoede',
      language = 'en',
      projectId,
      provider: requestedProvider,  // Provider from UI
      voiceInstructions,             // OpenAI voice instructions
      voiceStability = 0.5,          // ElevenLabs stability
      voiceSimilarityBoost = 0.75,   // ElevenLabs similarity boost
      voiceStyle = 0.5,              // ElevenLabs style
    }: TTSRequest = await request.json();

    if (!text) {
      return NextResponse.json({ error: 'Text is required' }, { status: 400 });
    }

    const session = await auth();
    let ttsProvider: TTSProvider = requestedProvider || 'gemini-tts';  // Use UI provider first
    let geminiApiKey = process.env.GEMINI_API_KEY;
    let elevenLabsApiKey = process.env.ELEVENLABS_API_KEY;
    let openaiApiKey = process.env.OPENAI_API_KEY;
    let modalTtsEndpoint: string | null = null;

    if (session?.user?.id) {
      const userApiKeys = await prisma.apiKeys.findUnique({
        where: { userId: session.user.id },
      });

      if (userApiKeys) {
        // Only use DB provider if not specified in request
        if (!requestedProvider) {
          ttsProvider = (userApiKeys.ttsProvider as TTSProvider) || 'gemini-tts';
        }
        if (userApiKeys.geminiApiKey) geminiApiKey = userApiKeys.geminiApiKey;
        if (userApiKeys.elevenLabsApiKey) elevenLabsApiKey = userApiKeys.elevenLabsApiKey;
        if (userApiKeys.openaiApiKey) openaiApiKey = userApiKeys.openaiApiKey;
        modalTtsEndpoint = userApiKeys.modalTtsEndpoint;
      }

      const balanceCheck = await checkBalance(session.user.id, COSTS.VOICEOVER_LINE);
      if (!balanceCheck.hasEnough) {
        return NextResponse.json({
          error: 'Insufficient credits',
          required: balanceCheck.required,
          balance: balanceCheck.balance,
          needsPurchase: true,
        }, { status: 402 });
      }
    }

    console.log(`[TTS] Using provider: ${ttsProvider}`);

    if (ttsProvider === 'modal') {
      if (!modalTtsEndpoint) {
        return NextResponse.json(
          { error: 'Modal TTS endpoint not configured. Please add your endpoint URL in Settings.' },
          { status: 400 }
        );
      }
      const result = await generateWithModal(text, voiceId, language, projectId, modalTtsEndpoint, session?.user?.id);
      return NextResponse.json(result);
    }

    if (ttsProvider === 'elevenlabs') {
      if (!elevenLabsApiKey) {
        return NextResponse.json(
          { error: 'ElevenLabs API key not configured. Please add your API key in Settings.' },
          { status: 500 }
        );
      }
      const result = await generateWithElevenLabs(text, voiceId, projectId, elevenLabsApiKey, session?.user?.id, voiceStability, voiceSimilarityBoost, voiceStyle);
      return NextResponse.json(result);
    }

    if (ttsProvider === 'openai-tts') {
      if (!openaiApiKey) {
        return NextResponse.json(
          { error: 'OpenAI API key not configured. Please add your API key in Settings.' },
          { status: 500 }
        );
      }
      const result = await generateWithOpenAI(text, voiceId, language, projectId, openaiApiKey, session?.user?.id, voiceInstructions);
      return NextResponse.json(result);
    }

    // Default to Gemini
    if (!geminiApiKey) {
      return NextResponse.json(
        { error: 'Gemini API key not configured. Please add your API key in Settings.' },
        { status: 500 }
      );
    }
    const result = await generateWithGemini(text, voiceName, language, projectId, geminiApiKey, session?.user?.id);
    return NextResponse.json(result);

  } catch (error) {
    console.error('TTS generation error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
